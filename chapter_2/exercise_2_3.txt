;; Borrow our implementation of the procedure `sqrt`
;; from the solution to Exercise 1.46
(define (iterative-improve good-enough? improve)
  (lambda (guess)
    (define (iter x)
      (if (good-enough? x)
           x
           (iter (improve x))))
     (iter guess)))

(define (sqrt x)
  (define tolerance 0.0001)
  (define (square x) (* x x))
  (define (close-enough? guess x)
    (< (abs (- (square guess) x))
       tolerance))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (average a b)
    (/ (+ a b) 2))
  ((iterative-improve (lambda (y) (close-enough? y x)) (lambda (y) (improve y x))) 1.0))

;; Implement a rectangle representation based on
;; perpendicular line segments that share a vertex
;; coercing to fit the constraint:
;;    "the end of segment-A is the start of segment-B"

;; Define a procedure for checking if two segments are perpendicular to one another
;; (using the Pythagorean Theorem). The following must be true of the inputs:
;;    "the end of A is the start of B"
(define (perp? A B)
  (define tolerance 2e-4) ; does this (in general) need to be on the same order of magnitude as tolerance in the sqrt procedure?
  (define (square x) (* x x))
  (define (seg-length seg)
    (let ((dx (- (x-point (start-segment seg)) (x-point (end-segment seg))))
          (dy (- (y-point (start-segment seg)) (y-point (end-segment seg)))))
      (sqrt (+ (square dx) (square dy)))))
  (let ((C (make-segment (start-segment A) (end-segment B))))
    (< (abs (- (square (seg-length C))
               (+ (square (seg-length A))
                  (square (seg-length B)))))
        tolerance)))

;; Implement a rectangle representation based on
;; perpendicular line segments that share a vertex
;; coercing to fit the constraint: "the end of segment-A is the start of segment-B"
;; (so that the perp procedure can be used)
(define (make-rectangle seg-A seg-B)
  (let ((A-start (start-segment seg-A))
        (A-end (end-segment seg-A))
        (B-start (start-segment seg-B))
        (B-end (end-segment seg-B)))
    (cond ((equal? A-start B-start)
              (let ((A (make-segment A-end A-start))
                    (B seg-B))
                (if (perp? A B) (cons A B))))
           ((equal? A-start B-end)
              (let ((A (make-segment A-end A-start))
                    (B (make-segment B-end B-start)))
                (if (perp? A B) (cons A B))))
           ((equal? A-end B-start)
              (let ((A seg-A)
                    (B seg-B))
                (if (perp? A B) (cons A B))))
           ((equal? A-end B-end)
              (let ((A seg-A)
                    (B (make-segment B-end B-start)))
                (if (perp? A B) (cons A B)))))))

;; Now test
(define A (make-segment (make-point 0 1) (make-point 0 0)))
(define B (make-segment (make-point 0 0) (make-point 1 0)))

(make-rectangle A B)

(make-rectangle B A)

(define C (make-segment (make-point 1 1) (make-point 0 0)))
(define D (make-segment (make-point 1 -1) (make-point 0 0)))

(make-rectangle C D)

(make-rectangle D C)
